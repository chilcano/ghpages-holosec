---
layout: post
title: Mass provisioning of Kismet and Apache MiNiFi in Raspberry Pi using Ansible
date: 2017-03-20 22:35:53.000000000 +01:00
type: post
parent_id: '0'
published: true
password: ''
status: publish
categories:
- Big Data
- DevOps
- IoT
- Security
tags:
- Ansible
- Apache MiNiFi
- Apache NiFi
- Data Ingestion
- Kismet
- Raspberry Pi
meta:
  _wpcom_is_markdown: '1'
  _oembed_d546af9e83efc44efb2d574ada150241: "{{unknown}}"
  _oembed_f4f1a075c349ac93cc75b88fae67dc9a: "{{unknown}}"
  _oembed_7b1bd08f14538f8238b1195ac34cecd6: "{{unknown}}"
  _oembed_e91c5a09c5a356defcb6679cf44eea8e: "{{unknown}}"
  _oembed_1cf4de4c1e78e19cb9b9892f6db43b93: "{{unknown}}"
  _oembed_340c2b54988eb85d72afe55017a06696: "{{unknown}}"
  _edit_last: '578869'
  geo_public: '0'
  _publicize_job_id: '3085006956'
  _publicize_done_external: a:1:{s:7:"twitter";a:1:{i:13849;s:54:"https://twitter.com/Chilcano/status/843939205218754561";}}
  _publicize_done_17477: '1'
  _wpas_done_13849: '1'
  publicize_twitter_user: Chilcano
  _oembed_b712e01c25b194119756dee2569ba6d9: "{{unknown}}"
  publicize_linkedin_url: https://www.linkedin.com/updates?discuss=&scope=6985267&stype=M&topic=6249704900129882112&type=U&a=lyQt
  _publicize_done_5110110: '1'
  _wpas_done_5053092: '1'
  _oembed_d7aa3d9459ac18bd9358c3b267d79711: "{{unknown}}"
  _oembed_bbdffdf8ebfc751c619f12f062c6c38b: "{{unknown}}"
  _oembed_b37edbde9115a9f34d7f991d5a61d69e: "{{unknown}}"
  _oembed_170fc14fc0f551a1a0338594ae00941e: "{{unknown}}"
  _oembed_be8337e0db71a664f79fb7fabfed57f0: "{{unknown}}"
  _oembed_a844877885754e58c95a498296ed765a: "{{unknown}}"
  _oembed_9fddc073e6b9ae82705718b0954c44ea: '<blockquote class="wp-embedded-content"
    data-secret="CgmQyiw2mV"><a href="http://blog.smalleycreative.com/linux/setup-a-headless-raspberry-pi-with-raspbian-jessie-on-os-x/">Setup
    a Headless Raspberry Pi with Raspbian Jessie on OS X</a></blockquote><iframe title="&#8220;Setup
    a Headless Raspberry Pi with Raspbian Jessie on OS X&#8221; &#8212; the smalley
    creative blog" class="wp-embedded-content" sandbox="allow-scripts" security="restricted"
    style="position: absolute; clip: rect(1px, 1px, 1px, 1px);" src="http://blog.smalleycreative.com/linux/setup-a-headless-raspberry-pi-with-raspbian-jessie-on-os-x/embed/#?secret=CgmQyiw2mV"
    data-secret="CgmQyiw2mV" width="600" height="338" frameborder="0" marginwidth="0"
    marginheight="0" scrolling="no"></iframe>'
  _oembed_time_9fddc073e6b9ae82705718b0954c44ea: '1570527689'
  _oembed_0b68709566ffdc504190b14cdd8bcdd1: "{{unknown}}"
author:
  login: rcarhuatocto
  email: roger@intix.info
  display_name: Roger CARHUATOCTO
  first_name: ''
  last_name: ''
permalink: "/2017/03/20/mass-provisioning-of-kismet-and-apache-minifi-in-raspberry-pi-using-ansible/"
---
<p>Lately I'm focusing on Automation in Big-Data Projects, and with my experience in Cyber Security I can bring new approaches and ideas to those Big-Data Projects are related to IT Security aspects (Threat Analisys, Privacy, Intrusion Detection, etc.).<br />
With this post I will start a serie of articles explaining how to do "Data Ingestion/Capture" in the <code>Edge</code> by using:</p>
<ul>
<li>Ansible to <code>provisioning</code>.</li>
<li>Multiple and remote devices in the <code>Edge</code> (Raspberry Pi).</li>
<li>Kismet to capture WIFI Anonymous traffic in the <code>Edge</code>.</li>
<li>Apache MiNiFi to enrich and route the captured traffic in the <code>Edge</code>.</li>
<li>Apache NiFi to collect the enriched traffic and forward to Solr / ElasticSearch.</li>
</ul>
<p>...everything, near to real-time ;)</p>
<p>And if you want to explore in deep other use cases, this article is a must read: (EDGE INTELLIGENCE FOR IOT WITH APACHE MINIFI)[https://hortonworks.com/blog/edge-intelligence-iot-apache-minifi/]</p>
<p>In short, I will explain in this post the following:<br />
- Manage several devices in the <code>Edge</code> by using Ansible.<br />
- Mass provision of Kismet and Apache MiNiFi.<br />
- Performing operational tasks in several devices.</p>
<p>[caption width="1229" align="alignnone"]<img src="{{ site.baseurl }}/assets/mass-provisioning-kismet-minifi-raspberrypi-ansible-1-arch.png" width="1229" height="654" alt="Mass provisioning of Kismet and Apache MiNiFi in Raspberry Pi using Ansible - Architecture" class="size-medium" /> Mass provisioning of Kismet and Apache MiNiFi in Raspberry Pi using Ansible - Architecture[/caption]</p>
<h2>1. Preparing your Raspberry Pi.</h2>
<h3>1.1. Prepare your MicroSD cards with the latest Raspbian image.</h3>
<p>I'm going to use Raspbian Jessie Lite 2017-01-11 (http://director.downloads.raspberrypi.org/raspbian_lite/images/raspbian_lite-2017-01-10/2017-01-11-raspbian-jessie-lite.zip).</p>
<p>[code lang=text]<br />
$ diskutil list</p>
<p>$ diskutil unmountDisk /dev/disk3</p>
<p>$ sudo dd bs=1m if=2017-01-11-raspbian-jessie-lite.img of=/dev/rdisk3</p>
<p>$ touch /Volumes/boot/ssh</p>
<p>$ diskutil unmountDisk /dev/disk3<br />
[/code]</p>
<p>... repeat this process as times as Raspberry Pis you have.</p>
<h3>1.2. Connect all Raspberry Pis to the Network.</h3>
<p>Connect all Raspberry Pi to your Router, now your PC and all Pis are connected to same network, and if you have DHCP enabled your Raspberry Pi will have an IP address automatically.<br />
Now, we have to get all IP addresses assigned to each Raspberry Pi. You could use Fing App in Android or install Fing in your PC.<br />
I'm going to use <a href="https://www.fing.io/download-free-ip-scanner-for-desktop-linux-windows-and-osx">Fing on Mac OSX</a>.</p>
<p>[code lang=text]<br />
$ sudo fing<br />
Password:</p>
<p>19:58:18 &gt; Discovery profile: Default discovery profile<br />
19:58:18 &gt; Discovery class:   data-link (data-link layer)<br />
19:58:18 &gt; Discovery on:      192.168.0.0/24<br />
...<br />
19:58:18 &gt; Host is up:   192.168.0.17<br />
           HW Address:   B8:27:EB:1E:12:63 (Raspberry Pi Foundation)</p>
<p>19:58:18 &gt; Host is up:   192.168.0.18<br />
           HW Address:   B8:27:EB:9C:C2:E3 (Raspberry Pi Foundation)</p>
<p>19:58:18 &gt; Host is up:   192.168.0.19<br />
           HW Address:   B8:27:EB:F0:F3:EA (Raspberry Pi Foundation)</p>
<p>19:58:18 &gt; Host is up:   192.168.0.20<br />
           HW Address:   B8:27:EB:5A:B5:5D (Raspberry Pi Foundation)<br />
...<br />
[/code]</p>
<p>You could try this too from your Mac OSX:</p>
<p>[code lang=text]<br />
$ arp -a -i en0</p>
<p>? (192.168.0.1) at 90:21:6:89:82:a9 on en0 ifscope [ethernet]<br />
? (192.168.0.5) at c4:57:6e:94:91:c2 on en0 ifscope [ethernet]<br />
? (192.168.0.10) at 44:65:d:9d:4e:3e on en0 ifscope [ethernet]<br />
? (192.168.0.17) at b8:27:eb:1e:12:63 on en0 ifscope [ethernet]<br />
? (192.168.0.18) at b8:27:eb:9c:c2:e3 on en0 ifscope [ethernet]<br />
? (192.168.0.19) at b8:27:eb:f0:f3:ea on en0 ifscope [ethernet]<br />
? (192.168.0.20) at b8:27:eb:5a:b5:5d on en0 ifscope [ethernet]<br />
? (192.168.0.255) at (incomplete) on en0 ifscope [ethernet]<br />
? (224.0.0.251) at 1:0:5e:0:0:fb on en0 ifscope permanent [ethernet]<br />
? (239.255.255.250) at 1:0:5e:7f:ff:fa on en0 ifscope permanent [ethernet]<br />
broadcasthost (255.255.255.255) at (incomplete) on en0 ifscope [ethernet]<br />
[/code]</p>
<p>Now, open a Terminal and connect through SSH to each Raspberry Pi just to verify the connection with your devices.</p>
<p>[code lang=text]<br />
$ ssh pi@192.168.0.17<br />
[/code]</p>
<p>With this information (MAC and IP addresses) I'm ready to start with Ansible to do automation on my Raspberry Pi Cluster.</p>
<h3>1.3. Initial configuration and provision for all Raspberry Pi through Ansible.</h3>
<p>To do the initial configuration in all Raspberry Pis I've used the next:<br />
- The <a href="https://github.com/geerlingguy/raspberry-pi-dramble">Raspberry Pi Dramble Ansible Git repository</a>. Although these Ansible Playbooks are to provision an Apache HTTPd, Drupal, MySQL Cluster, our intention is to use it initially to manage the Raspberry Pi cluster at infrastructure level.<br />
- The <a href="https://github.com/mikolak-net/ansible-raspi-config">mikolak.raspi-config</a> Ansible Role to configure each Raspberry Pi like if used <a href="https://www.raspberrypi.org/documentation/configuration/raspi-config.md">raspi-config</a> tool.</p>
<p>That means:</p>
<ul>
<li>Resize SD, update Raspbian and manage shutdown and reboot operations.</li>
<li>Set a proper Hostname, configure Network interfaces (eth0 and wlan0), DNS, etc.</li>
</ul>
<p>I've updated and extended the <a href="https://github.com/geerlingguy/raspberry-pi-dramble">Raspberry Pi Dramble Ansible Git repository</a> to reset the Network configuration and to build from source code, to install and to start Kismet (http://www.kismetwireless.net).</p>
<p>You can download my Ansible Playbooks from here: https://github.com/chilcano/ansible-raspberrypi-wardriving</p>
<p>[code lang=text]<br />
$ git clone https://github.com/chilcano/ansible-raspberrypi-wardriving</p>
<p>$ cd ansible-raspberrypi-wardriving<br />
[/code]</p>
<p>Now update <code>networking/inventory</code>. You will need to use all MAC Addresses and IP assigned to each Raspberry Pi collected in previous step. The final file look like:</p>
<p>[code lang=text]<br />
$ nano setup/networking/inventory</p>
<p>[pis]<br />
192.168.0.17<br />
192.168.0.18<br />
192.168.0.19<br />
192.168.0.20</p>
<p>[pis:vars]<br />
ansible_ssh_user=pi<br />
ansible_ssh_user_new=picuy<br />
path_to_ssh_key=/Users/Chilcano/.ssh/id_rsa.pub<br />
[/code]</p>
<p>And update <code>networking/vars.yml</code>.</p>
<p>[code lang=text]<br />
$ nano setup/networking/vars.yml</p>
<p>---<br />
# Mapping of what hardware MAC addresses should be configured with specific IPs.<br />
mac_address_mapping:<br />
  &quot;b8:27:eb:1e:12:63&quot;:<br />
    name: rpi17.intix.info<br />
    ip: &quot;192.168.0.17&quot;<br />
  &quot;b8:27:eb:9c:c2:e3&quot;:<br />
    name: rpi18.intix.info<br />
    ip: &quot;192.168.0.18&quot;<br />
  &quot;b8:27:eb:f0:f3:ea&quot;:<br />
    name: rpi19.intix.info<br />
    ip: &quot;192.168.0.19&quot;<br />
  &quot;b8:27:eb:5a:b5:5d&quot;:<br />
    name: rpi20.intix.info<br />
    ip: &quot;192.168.0.20&quot;</p>
<p># Nameservers to use in resolv.conf.<br />
dns_nameservers:<br />
  - &quot;8.8.8.8&quot;<br />
  - &quot;8.8.4.4&quot;</p>
<p>gateway:<br />
  eth0: &quot;192.168.0.1&quot;<br />
  wlan0: &quot;192.168.0.1&quot;</p>
<p>rpi_nic_static:<br />
  eth0: false<br />
  wlan0: false<br />
[/code]</p>
<p>Finally, It is time to run the Ansible Playbook to provision the initial configuration.</p>
<p>[code lang=text]<br />
$ cd setup/networking</p>
<p>$ ansible-playbook -i inventory main.yml -k</p>
<p>SSH password:</p>
<p>PLAY ***************************************************************************</p>
<p>TASK [setup] *******************************************************************</p>
<p>paramiko: The authenticity of host &#039;192.168.0.17&#039; can&#039;t be established.<br />
The ssh-rsa key fingerprint is 66cf86cb30b2ca92658808f26d453c31.<br />
Are you sure you want to continue connecting (yes/no)?<br />
yes</p>
<p>paramiko: The authenticity of host &#039;192.168.0.20&#039; can&#039;t be established.<br />
The ssh-rsa key fingerprint is 7d259fe2fcf0b36164441bd4dbee321e.<br />
Are you sure you want to continue connecting (yes/no)?<br />
yes</p>
<p>paramiko: The authenticity of host &#039;192.168.0.18&#039; can&#039;t be established.<br />
The ssh-rsa key fingerprint is de91abe013a8af491d0c8aa5b5d6a9aa.<br />
Are you sure you want to continue connecting (yes/no)?<br />
yes</p>
<p>paramiko: The authenticity of host &#039;192.168.0.19&#039; can&#039;t be established.<br />
The ssh-rsa key fingerprint is 447a195e33bbee9d4479ed46110dd3d4.<br />
Are you sure you want to continue connecting (yes/no)?<br />
yes<br />
ok: [192.168.0.17]<br />
ok: [192.168.0.18]<br />
ok: [192.168.0.20]<br />
ok: [192.168.0.19]</p>
<p>TASK [Set the current MAC address for eth0.] ***********************************<br />
ok: [192.168.0.17]<br />
ok: [192.168.0.18]<br />
ok: [192.168.0.19]<br />
ok: [192.168.0.20]</p>
<p>TASK [Set variables based on eth0 MAC address.] ********************************<br />
ok: [192.168.0.17]<br />
ok: [192.168.0.18]<br />
ok: [192.168.0.19]<br />
ok: [192.168.0.20]</p>
<p>TASK [Set up networking-related files.] ****************************************<br />
changed: [192.168.0.18] =&gt; (item={u&#039;dest&#039;: u&#039;/etc/hostname&#039;, u&#039;template&#039;: u&#039;hostname.j2&#039;})<br />
changed: [192.168.0.18] =&gt; (item={u&#039;dest&#039;: u&#039;/etc/hosts&#039;, u&#039;template&#039;: u&#039;hosts.j2&#039;})<br />
changed: [192.168.0.18] =&gt; (item={u&#039;dest&#039;: u&#039;/etc/network/interfaces&#039;, u&#039;template&#039;: u&#039;interfaces.j2&#039;})<br />
changed: [192.168.0.18] =&gt; (item={u&#039;dest&#039;: u&#039;/etc/resolv.conf&#039;, u&#039;template&#039;: u&#039;resolv.conf.j2&#039;})<br />
changed: [192.168.0.18] =&gt; (item={u&#039;dest&#039;: u&#039;/etc/dhcpcd.conf&#039;, u&#039;template&#039;: u&#039;dhcpcd.conf.j2&#039;})<br />
changed: [192.168.0.17] =&gt; (item={u&#039;dest&#039;: u&#039;/etc/hostname&#039;, u&#039;template&#039;: u&#039;hostname.j2&#039;})<br />
changed: [192.168.0.17] =&gt; (item={u&#039;dest&#039;: u&#039;/etc/hosts&#039;, u&#039;template&#039;: u&#039;hosts.j2&#039;})<br />
changed: [192.168.0.17] =&gt; (item={u&#039;dest&#039;: u&#039;/etc/network/interfaces&#039;, u&#039;template&#039;: u&#039;interfaces.j2&#039;})<br />
changed: [192.168.0.17] =&gt; (item={u&#039;dest&#039;: u&#039;/etc/resolv.conf&#039;, u&#039;template&#039;: u&#039;resolv.conf.j2&#039;})<br />
changed: [192.168.0.17] =&gt; (item={u&#039;dest&#039;: u&#039;/etc/dhcpcd.conf&#039;, u&#039;template&#039;: u&#039;dhcpcd.conf.j2&#039;})<br />
changed: [192.168.0.19] =&gt; (item={u&#039;dest&#039;: u&#039;/etc/hostname&#039;, u&#039;template&#039;: u&#039;hostname.j2&#039;})<br />
changed: [192.168.0.19] =&gt; (item={u&#039;dest&#039;: u&#039;/etc/hosts&#039;, u&#039;template&#039;: u&#039;hosts.j2&#039;})<br />
changed: [192.168.0.19] =&gt; (item={u&#039;dest&#039;: u&#039;/etc/network/interfaces&#039;, u&#039;template&#039;: u&#039;interfaces.j2&#039;})<br />
changed: [192.168.0.19] =&gt; (item={u&#039;dest&#039;: u&#039;/etc/resolv.conf&#039;, u&#039;template&#039;: u&#039;resolv.conf.j2&#039;})<br />
changed: [192.168.0.19] =&gt; (item={u&#039;dest&#039;: u&#039;/etc/dhcpcd.conf&#039;, u&#039;template&#039;: u&#039;dhcpcd.conf.j2&#039;})<br />
changed: [192.168.0.20] =&gt; (item={u&#039;dest&#039;: u&#039;/etc/hostname&#039;, u&#039;template&#039;: u&#039;hostname.j2&#039;})<br />
changed: [192.168.0.20] =&gt; (item={u&#039;dest&#039;: u&#039;/etc/hosts&#039;, u&#039;template&#039;: u&#039;hosts.j2&#039;})<br />
changed: [192.168.0.20] =&gt; (item={u&#039;dest&#039;: u&#039;/etc/network/interfaces&#039;, u&#039;template&#039;: u&#039;interfaces.j2&#039;})<br />
changed: [192.168.0.20] =&gt; (item={u&#039;dest&#039;: u&#039;/etc/resolv.conf&#039;, u&#039;template&#039;: u&#039;resolv.conf.j2&#039;})<br />
changed: [192.168.0.20] =&gt; (item={u&#039;dest&#039;: u&#039;/etc/dhcpcd.conf&#039;, u&#039;template&#039;: u&#039;dhcpcd.conf.j2&#039;})</p>
<p>RUNNING HANDLER [update hostname] **********************************************<br />
changed: [192.168.0.19]<br />
changed: [192.168.0.18]<br />
changed: [192.168.0.17]<br />
changed: [192.168.0.20]</p>
<p>RUNNING HANDLER [delete dhcp leases] *******************************************<br />
changed: [192.168.0.19] =&gt; (item=/var/lib/dhcp/dhclient.leases)<br />
ok: [192.168.0.19] =&gt; (item=/var/lib/dhcpcd5/dhcpcd-eth0.lease)<br />
changed: [192.168.0.17] =&gt; (item=/var/lib/dhcp/dhclient.leases)<br />
ok: [192.168.0.17] =&gt; (item=/var/lib/dhcpcd5/dhcpcd-eth0.lease)<br />
changed: [192.168.0.18] =&gt; (item=/var/lib/dhcp/dhclient.leases)<br />
ok: [192.168.0.18] =&gt; (item=/var/lib/dhcpcd5/dhcpcd-eth0.lease)<br />
changed: [192.168.0.20] =&gt; (item=/var/lib/dhcp/dhclient.leases)<br />
ok: [192.168.0.20] =&gt; (item=/var/lib/dhcpcd5/dhcpcd-eth0.lease)</p>
<p>PLAY RECAP *********************************************************************<br />
192.168.0.17               : ok=6    changed=3    unreachable=0    failed=0<br />
192.168.0.18               : ok=6    changed=3    unreachable=0    failed=0<br />
192.168.0.19               : ok=6    changed=3    unreachable=0    failed=0<br />
192.168.0.20               : ok=6    changed=3    unreachable=0    failed=0<br />
[/code]</p>
<p>The above result means you have connected to each Raspberry Pi and a proper Hostname based on each MAC Address have been assigned successfully.<br />
First of all, I will check that using Ansible.</p>
<p>[code lang=text]<br />
$ cd ansible-raspberrypi-wardriving/setup/networking</p>
<p>$ ansible pis -i inventory -m ping -k</p>
<p>SSH password:<br />
192.168.0.19 | SUCCESS =&gt; {<br />
    &quot;changed&quot;: false,<br />
    &quot;ping&quot;: &quot;pong&quot;<br />
}<br />
192.168.0.18 | SUCCESS =&gt; {<br />
    &quot;changed&quot;: false,<br />
    &quot;ping&quot;: &quot;pong&quot;<br />
}<br />
192.168.0.17 | SUCCESS =&gt; {<br />
    &quot;changed&quot;: false,<br />
    &quot;ping&quot;: &quot;pong&quot;<br />
}<br />
192.168.0.20 | SUCCESS =&gt; {<br />
    &quot;changed&quot;: false,<br />
    &quot;ping&quot;: &quot;pong&quot;<br />
}<br />
[/code]</p>
<p>Now, you can use SSH to connect to all Raspberry Pi and check the hostname assigned.</p>
<p>[code lang=text]<br />
$ ssh picuy@192.168.0.17<br />
picuy@192.168.0.17&#039;s password:</p>
<p>The programs included with the Debian GNU/Linux system are free software;<br />
the exact distribution terms for each program are described in the<br />
individual files in /usr/share/doc/*/copyright.</p>
<p>Debian GNU/Linux comes with ABSOLUTELY NO WARRANTY, to the extent<br />
permitted by applicable law.<br />
Last login: Tue Feb 14 22:02:13 2017 from 192.168.0.3</p>
<p>SSH is enabled and the default password for the &#039;pi&#039; user has not been changed.<br />
This is a security risk - please login as the &#039;pi&#039; user and type &#039;passwd&#039; to set a new password.</p>
<p>picuy@rpi17:~ $ exit<br />
[/code]</p>
<p>In this point, you will be able to continue configuring your Raspberry Pis through Ansible Playbook performing Linux commands remotely.</p>
<h3>1.4. Performing Linux commands remotely through Ansible.</h3>
<p><em>Get free memory available in each Raspberry Pi.</em></p>
<p>[code lang=text]<br />
$ ansible pis -i inventory -a &quot;free -m&quot; -k<br />
SSH password:<br />
192.168.0.18 | SUCCESS | rc=0 &gt;&gt;<br />
             total       used       free     shared    buffers     cached<br />
Mem:           925         87        837          6          9         43<br />
-/+ buffers/cache:         35        890<br />
Swap:           99          0         99</p>
<p>192.168.0.17 | SUCCESS | rc=0 &gt;&gt;<br />
             total       used       free     shared    buffers     cached<br />
Mem:           925         87        838          6          9         43<br />
-/+ buffers/cache:         34        890<br />
Swap:           99          0         99</p>
<p>192.168.0.19 | SUCCESS | rc=0 &gt;&gt;<br />
             total       used       free     shared    buffers     cached<br />
Mem:           925         89        835          6          9         43<br />
-/+ buffers/cache:         37        888<br />
Swap:           99          0         99</p>
<p>192.168.0.20 | SUCCESS | rc=0 &gt;&gt;<br />
             total       used       free     shared    buffers     cached<br />
Mem:           434         74        359          4          9         37<br />
-/+ buffers/cache:         27        406<br />
Swap:           99          0         99<br />
[/code]</p>
<p><em>Performing different Linux commands.</em></p>
<p>[code lang=text]<br />
$ ansible pis -i inventory -a &quot;cat /etc/hostname&quot; -k</p>
<p>$ ansible pis -i inventory -a &quot;cat /etc/hosts&quot; -k</p>
<p>$ ansible pis -i inventory -a &quot;ping -c 2 pi17.intix.info&quot; -k</p>
<p>$ ansible pis -i inventory -a &quot;ping -c 3 holisticsecurity.io&quot; -k</p>
<p>$ ansible pis -i inventory -a &quot;df -h&quot; -k<br />
[/code]</p>
<p>But, if some command require <code>sudo</code> you can provide it using <code>-s</code> flag, although it is deprecated, it is still valid.</p>
<p>[code lang=text]<br />
$ ansible pis -i inventory -a &quot;ifconfig wlan0&quot; -s -k<br />
[/code]</p>
<p>...or rebooting all Raspberry Pi.</p>
<p>[code lang=text]<br />
$ ansible pis -i inventory -a &quot;shutdown -r now&quot; -s -k</p>
<p>SSH password:<br />
192.168.0.18 | SUCCESS | rc=0 &gt;&gt;</p>
<p>192.168.0.17 | SUCCESS | rc=0 &gt;&gt;</p>
<p>192.168.0.19 | SUCCESS | rc=0 &gt;&gt;</p>
<p>No handlers could be found for logger &quot;paramiko.transport&quot;<br />
192.168.0.20 | SUCCESS | rc=0 &gt;&gt;<br />
[/code]</p>
<h3>1.5. Restoring the network configuration.</h3>
<p>If you try to connect to one Raspberry Pi and the SSH connection is taking a few seconds, or if you are running ping www.google.com and Raspberry Pi is not reaching that. Then, you probably are facing issues with gateway and networking configuration in your Raspberry Pi and need restore or enable default configuration.<br />
Then, let's go to check the network configuration, basically you have to check these files in each Raspberry Pi:</p>
<ul>
<li>/etc/dhcpcd.conf</li>
<li>/etc/hosts</li>
<li>/etc/network/interfaces</li>
</ul>
<p>I've updated above cloned Ansible scripts for you with the right configuration. Basically I have updated the Ansible templates (Jinja2) to do:</p>
<ul>
<li>Restoring <code>etc/network/interfaces</code> to get IP address automatically through DHCP.</li>
<li>Configuring <code>/etc/dhcpcd.conf</code> with our default gateway on eth0.</li>
</ul>
<p>Also I have updated the <code>setup/networking/main.yml</code> Ansible Playbook and the <code>setup/networking/vars.yml</code> to restore default network configuration.</p>
<p>Again, run the updated Ansible Playbook and verify if the changes with the right gateway, DNS, etc. were applied.</p>
<p>[code lang=text]<br />
$ ansible-playbook -i inventory main.yml -k<br />
[/code]</p>
<h3>1.6. Set IP address automatically through DHCP on eth0.</h3>
<p>In previous step I updated the Ansible Playbooks and Jinja2 templates to restore default assignation of IP addresses through DHCP.<br />
Well, now I'm going to use it. Just update <code>setup\networking\vars.yml</code> setting <code>rpi_nic_static.eth0</code> to <code>false</code>.</p>
<p>Run <code>fing</code> to get all IP addresses re-assigned to all Raspberry Pis and update the <code>setup\networking\inventory</code> and provision your new configuration.</p>
<p>[code lang=text]<br />
$ ansible-playbook -i inventory main.yml -k<br />
[/code]</p>
<h2>2. Massive provisioning of Kismet through Ansible on multiples Raspberry Pi.</h2>
<p>I'm going to create an Ansible Playbooks to:</p>
<ul>
<li>Enable WIFI interface in <code>monitor mode</code> on each Raspberry Pi.</li>
<li>Download Kismet source code and build it for Raspberry Pi (ARM chipset).</li>
<li>Install and configure Kismet on each Raspberry Pi.</li>
</ul>
<p>To do that I will follow my previous blog posts (<a href="https://holisticsecurity.io/2016/02/02/everything-generates-data-capturing-wifi-anonymous-traffic-raspberrypi-wso2-part-i">Capturing WIFI anonymous traffic using Raspberry Pi and WSO2 BAM - Part I</a>) where I explained step by step all commands to be performed in order to run Kismet on Raspberry Pi.<br />
The result final is a set of Ansible Playbooks located under <code>ansible-raspberrypi-wardriving/playbooks/kismet</code> in the Git repo (https://github.com/chilcano/ansible-raspberrypi-wardriving), and they are:</p>
<p>[code lang=text]<br />
$ tree ansible-raspberrypi-wardriving/playbooks/kismet</p>
<p>ansible-raspberrypi-wardriving/playbooks/kismet<br />
├── main_build.yml<br />
├── main_clean.yml<br />
├── main_install.yml<br />
├── tasks<br />
│   ├── build.yml<br />
│   ├── clean_installation.yml<br />
│   ├── install_from_deb.yml<br />
│   ├── kill_process.yml<br />
│   ├── localmirror.yml<br />
│   └── run_as_systemd.yml<br />
├── templates<br />
│   ├── description-pak.j2<br />
│   ├── kismet.conf.j2<br />
│   ├── kismet_drone.conf.j2<br />
│   ├── warpi.service.j2<br />
│   └── warpi.sh.j2<br />
└── vars.yml</p>
<p>2 directories, 15 files<br />
[/code]</p>
<p>Now, to run these Ansible Playbooks I have to follow the same steps above explained:<br />
- Get all IP addresses and MAC addresses.<br />
- Automatic assignation of IP addresses (DHCP).<br />
- Assignation of a proper hostname.<br />
- Change default username and password.</p>
<p>To do that, just follow the steps in section <code>1.3. Initial configuration and provision for all Raspberry Pi through Ansible</code> of this post.<br />
After that, You have to update your <code>ansible-raspberrypi-wardriving/inventory</code> and <code>ansible-raspberrypi-wardriving/playbooks/kismet/vars.yml</code> files.</p>
<p>Now, You are ready to run these Kismet Ansible Playbooks, then let's do it:</p>
<p>[code lang=text]<br />
$ cd ansible-raspberrypi-wardriving<br />
$ ansible-playbook -i inventory main_kismet_install.yml -k</p>
<p>[/code]</p>
<p>And if you get the below message, then you have already provisioned successfully Kismet in all Raspberry Pi configured in your <code>ansible-raspberrypi-wardriving/inventory</code>.</p>
<p>[code lang=text]<br />
...<br />
...<br />
TASK [Copying &#039;warpi.sh.j2&#039; template.] *****************************************<br />
changed: [192.168.0.19]<br />
changed: [192.168.0.18]</p>
<p>TASK [Copying &#039;warpi.service.j2&#039; template.] ************************************<br />
changed: [192.168.0.18]<br />
changed: [192.168.0.19]</p>
<p>TASK [Reloading &#039;warpi&#039; systemd service.] **************************************<br />
changed: [192.168.0.18]<br />
changed: [192.168.0.19]</p>
<p>TASK [Starting &#039;warpi&#039; systemd service.] ***************************************<br />
changed: [192.168.0.19]<br />
changed: [192.168.0.18]</p>
<p>TASK [debug] *******************************************************************<br />
ok: [192.168.0.18] =&gt; {<br />
    &quot;msg&quot;: &quot;Service &#039;warpi&#039; started successfully. Now Kismet is sending events on 2501 port ( nc -vz localhost 2501 )&quot;<br />
}<br />
ok: [192.168.0.19] =&gt; {<br />
    &quot;msg&quot;: &quot;Service &#039;warpi&#039; started successfully. Now Kismet is sending events on 2501 port ( nc -vz localhost 2501 )&quot;<br />
}</p>
<p>PLAY RECAP *********************************************************************<br />
192.168.0.18               : ok=34   changed=17   unreachable=0    failed=0<br />
192.168.0.19               : ok=37   changed=14   unreachable=0    failed=0<br />
[/code]</p>
<p>And if you connect to your Raspberry Pi through SSH you can the status of Kismet there:</p>
<p>[code lang=text]<br />
$ ssh picuy@192.168.0.19</p>
<p>...</p>
<p>picuy@rpi19:~ $ sudo systemctl status warpi<br />
● warpi.service - Enable monitor mode and manage Kismet Server as service<br />
   Loaded: loaded (/etc/systemd/system/warpi.service; enabled)<br />
   Active: active (running) since Fri 2017-03-17 11:25:17 UTC; 3min 39s ago<br />
 Main PID: 9023 (warpi.sh)<br />
   CGroup: /system.slice/warpi.service<br />
           ├─9023 /bin/sh /home/picuy/warpi.sh<br />
           └─9028 kismet_server</p>
<p>Mar 17 11:25:22 rpi19.intix.info warpi.sh[9023]: INFO: Detected new managed network &quot;BTWifi-with-FON&quot;, BSSID 02:03:D8:4D:17:<br />
Mar 17 11:25:22 rpi19.intix.info warpi.sh[9023]: 72, encryption no, channel 11, 144.40 mbit<br />
Mar 17 11:25:22 rpi19.intix.info warpi.sh[9023]: INFO: Detected new managed network &quot;EE-ej96p2&quot;, BSSID E4:3E:D7:DB:9E:53,<br />
Mar 17 11:25:22 rpi19.intix.info warpi.sh[9023]: encryption yes, channel 11, 144.40 mbit<br />
Mar 17 11:25:41 rpi19.intix.info warpi.sh[9023]: INFO: Detected new probe network &quot;&quot;, BSSID 88:32:9B:69:6F:3A,<br />
Mar 17 11:25:41 rpi19.intix.info warpi.sh[9023]: encryption no, channel 0, 72.20 mbit<br />
Mar 17 11:28:21 rpi19.intix.info warpi.sh[9023]: INFO: Detected new managed network &quot;BTHomeHub2-SS4C&quot;, BSSID 00:26:44:19:7B:<br />
Mar 17 11:28:21 rpi19.intix.info warpi.sh[9023]: CD, encryption yes, channel 7, 130.00 mbit<br />
Mar 17 11:28:28 rpi19.intix.info warpi.sh[9023]: INFO: Detected new managed network &quot;BTWiFi-with-FON&quot;, BSSID 02:26:44:19:7B:<br />
Mar 17 11:28:28 rpi19.intix.info warpi.sh[9023]: CF, encryption no, channel 7, 130.00 mbit<br />
[/code]</p>
<h2>3. Massive provisioning of Apache MiNiFi through Ansible on multiples Raspberry Pi.</h2>
<p>If you have not read my <a href="https://holisticsecurity.io/2016/12/02/data-routing-transformation-and-system-mediation-in-big-data-iot-scenarios-with-apache-nifi">previous post about Apache NiFi</a>, well I can say that is a Data Mediator Engine and ETL with steroids suitable for BigData Projects and Apache MiNiFi is the perfect complement to it for IoT Projects.<br />
Well, the scenario where I want to use Apache NiFi and Apache MiNiFi is in IoT, Security/Privacy space and the best way to validate this approach is using Ansible to do automation <code>massively</code> (Raspberry Pi in the <code>edge</code>) without pain.<br />
I've created Ansible Playbooks to manage the installation and configuration of Apache MiNiFi in Raspberry Pi, they are located under <code>ansible-raspberrypi-wardriving/playbooks/minifi</code> in the Git repo (https://github.com/chilcano/ansible-raspberrypi-wardriving), and they are:</p>
<p>[code lang=text]<br />
$ tree ansible-raspberrypi-wardriving/playbooks/minifi</p>
<p>ansible-raspberrypi-wardriving/playbooks/minifi<br />
├── main_clean.yml<br />
├── main_install.yml<br />
├── tasks<br />
│   ├── clean.yml<br />
│   ├── install.yml<br />
│   └── run.yml<br />
├── templates<br />
│   └── minifipi.service.j2<br />
└── vars.yml</p>
<p>2 directories, 7 files<br />
[/code]</p>
<p>The same Ansible Playbooks should work in other devices too.<br />
I'm going to repeat the same previous steps before running MiNiFi Ansible Playbooks. Check the section <code>2. Massive provisioning of Kismet through Ansible on multiples Raspberry Pi.</code> for further details.<br />
Now, You are ready to run these MiNiFi Ansible Playbooks, then let's do it:</p>
<p>[code lang=text]<br />
$ cd ansible-raspberrypi-wardriving</p>
<p>$ ansible-playbook -i inventory main_minifi_install.yml -k<br />
[/code]</p>
<p>And if you get the below message, then you have already provisioned successfully Apache MiNiFi in all Raspberry Pi configured in your <code>ansible-raspberrypi-wardriving/inventory</code>.</p>
<p>[code lang=text]<br />
...<br />
...<br />
TASK [debug] *******************************************************************<br />
ok: [192.168.0.18] =&gt; {<br />
    &quot;msg&quot;: &quot;The MiNiFi service &#039;minifipi.service&#039; has started successfully.&quot;<br />
}</p>
<p>PLAY RECAP *********************************************************************<br />
192.168.0.18               : ok=22   changed=8    unreachable=0    failed=0<br />
[/code]</p>
<p>Remember that you can execute the command remotely via Ansible, commands like <code>ping</code>, <code>shutdown</code>, <code>free</code>:</p>
<p>[code lang=text]<br />
$ cd ansible-raspberrypi-wardriving/setup/networking</p>
<p>$ ansible pis -i inventory -m ping -k</p>
<p>$ ansible pis -i inventory -a &quot;free -m&quot; -k<br />
[/code]</p>
<p>...and/or check the current status of MiNiFi and/or Kismet as below I explain:</p>
<p>[code lang=text]<br />
$ ansible pis -i inventory -a &quot;systemctl -p MainPID,ControlGroup,Id,Description,FragmentPath show *pi&quot; -k</p>
<p>192.168.0.17 | SUCCESS | rc=0 &gt;&gt;</p>
<p>192.168.0.44 | SUCCESS | rc=0 &gt;&gt;<br />
MainPID=685<br />
ControlGroup=/system.slice/warpi.service<br />
Id=warpi.service<br />
Description=Enable monitor mode and manage Kismet Server as service<br />
FragmentPath=/etc/systemd/system/warpi.service</p>
<p>MainPID=5490<br />
ControlGroup=/system.slice/minifipi.service<br />
Id=minifipi.service<br />
Description=Apache MiNiFi as service<br />
FragmentPath=/etc/systemd/system/minifipi.service<br />
[/code]</p>
<p>This results means:</p>
<ul>
<li>In RPi <code>192.168.0.17</code> the <code>warpi</code> (Kismet) and <code>minifipi</code> (MiNiFi) services are not running.</li>
<li>In RPi <code>192.168.0.18</code> the <code>warpi</code> (Kismet) and <code>minifipi</code> (MiNiFi) services are running.</li>
</ul>
<p>And if you want further details about the Apache MiNiFi running in RPi <code>192.168.0.18</code>, just execute this command:</p>
<p>[code lang=bash]<br />
$ ansible 192.168.0.18 -i inventory -a &quot;systemctl status minifipi&quot; -k</p>
<p>SSH password:<br />
192.168.0.18 | SUCCESS | rc=0 &gt;&gt;<br />
● minifipi.service - Apache MiNiFi as service<br />
   Loaded: loaded (/etc/systemd/system/minifipi.service; enabled)<br />
   Active: active (running) since Mon 2017-03-20 16:56:59 UTC; 42min ago<br />
  Process: 5474 ExecStart=/home/picuy/minifi-0.1.0/bin/minifi.sh start (code=exited, status=0/SUCCESS)<br />
 Main PID: 5490 (minifi.sh)<br />
   CGroup: /system.slice/minifipi.service<br />
           ├─5490 /bin/sh /home/picuy/minifi-0.1.0/bin/minifi.sh start<br />
           ├─5491 /usr/bin/java -cp /home/picuy/minifi-0.1.0/conf:/home/picuy/minifi-0.1.0/lib/bootstrap/*:/home/picuy/minifi-0.1.0/lib/* -Xms12m -Xmx24m -Dorg.apache.nifi.minifi.bootstrap.config.log.dir=/home/picuy/minifi-0.1.0/logs -Dorg.apache.nifi.minifi.bootstrap.config.pid.dir=/home/picuy/minifi-0.1.0/run -Dorg.apache.nifi.minifi.bootstrap.config.file=/home/picuy/minifi-0.1.0/conf/bootstrap.conf org.apache.nifi.minifi.bootstrap.RunMiNiFi start<br />
           └─5510 java -classpath /home/picuy/minifi-0.1.0/./conf:/home/picuy/minifi-0.1.0/./lib/jetty-util-9.3.9.v20160517.jar:/home/picuy/minifi-0.1.0/./lib/httpcore-nio-4.4.5.jar:/home/picuy/minifi-0.1.0/./lib/jsr311-api-1.1.1.jar:/home/picuy/minifi-0.1.0/./lib/commons-codec-1.10.jar:/home/picuy/minifi-0.1.0/./lib/httpasyncclient-4.1.1.jar:/home/picuy/minifi-0.1.0/./lib/jcl-over-slf4j-1.7.12.jar:/home/picuy/minifi-0.1.0/./lib/nifi-framework-core-1.1.0.jar:/home/picuy/minifi-0.1.0/./lib/jetty-server-9.3.9.v20160517.jar:/home/picuy/minifi-0.1.0/./lib/nifi-security-1.1.0.jar:/home/picuy/minifi-0.1.0/./lib/jetty-schemas-3.1.jar:/home/picuy/minifi-0.1.0/./lib/curator-recipes-2.11.0.jar:/home/picuy/minifi-0.1.0/./lib/jetty-security-9.3.9.v20160517.jar:/home/picuy/minifi-0.1.0/./lib/nifi-framework-authorization-1.1.0.jar:/home/picuy/minifi-0.1.0/./lib/nifi-api-1.1.0.jar:/home/picuy/minifi-0.1.0/./lib/nifi-properties-1.1.0.jar:/home/picuy/minifi-0.1.0/./lib/spring-core-4.2.4.RELEASE.jar:/home/picuy/minifi-0.1.0/./lib/nifi-properties-loader-1.1.0.jar:/home/picuy/minifi-0.1.0/./lib/antlr-runtime-3.5.2.jar:/home/picuy/minifi-0.1.0/./lib/json-path-2.0.0.jar:/home/picuy/minifi-0.1.0/./lib/nifi-web-utils-1.1.0.jar:/home/picuy/minifi-0.1.0/./lib/commons-lang3-3.4.jar:/home/picuy/minifi-0.1.0/./lib/nifi-security-utils-1.1.0.jar:/home/picuy/minifi-0.1.0/./lib/nifi-site-to-site-reporting-task-1.0.0.jar:/home/picuy/minifi-0.1.0/./lib/org.eclipse.jdt.core-3.8.2.v20130121.jar:/home/picuy/minifi-0.1.0/./lib/jersey-client-1.19.jar:/home/picuy/minifi-0.1.0/./lib/jul-to-slf4j-1.7.12.jar:/home/picuy/minifi-0.1.0/./lib/ecj-4.4.2.jar:/home/picuy/minifi-0.1.0/./lib/guava-18.0.jar:/home/picuy/minifi-0.1.0/./lib/jetty-webapp-9.3.9.v20160517.jar:/home/picuy/minifi-0.1.0/./lib/lucene-core-4.10.4.jar:/home/picuy/minifi-0.1.0/./lib/commons-collections4-4.0.jar:/home/picuy/minifi-0.1.0/./lib/apache-jsp-8.0.33.jar:/home/picuy/minifi-0.1.0/./lib/nifi-site-to-site-client-1.1.0.jar:/home/picuy/minifi-0.1.0/./lib/nifi-site-to-site-1.1.0.jar:/home/picuy/minifi-0.1.0/./lib/httpclient-4.4.1.jar:/home/picuy/minifi-0.1.0/./lib/jackson-jaxrs-1.9.2.jar:/home/picuy/minifi-0.1.0/./lib/jetty-xml-9.3.9.v20160517.jar:/home/picuy/minifi-0.1.0/./lib/nifi-data-provenance-utils-1.1.0.jar:/home/picuy/minifi-0.1.0/./lib/curator-framework-2.11.0.jar:/home/picuy/minifi-0.1.0/./lib/curator-client-2.11.0.jar:/home/picuy/minifi-0.1.0/./lib/javax.servlet-api-3.1.0.jar:/home/picuy/minifi-0.1.0/./lib/jersey-core-1.19.jar:/home/picuy/minifi-0.1.0/./lib/jetty-servlet-9.3.9.v20160517.jar:/home/picuy/minifi-0.1.0/./lib/jetty-servlets-9.3.9.v20160517.jar:/home/picuy/minifi-0.1.0/./lib/nifi-runtime-1.1.0.jar:/home/picuy/minifi-0.1.0/./lib/jackson-annotations-2.6.0.jar:/home/picuy/minifi-0.1.0/./lib/nifi-framework-api-1.1.0.jar:/home/picuy/minifi-0.1.0/./lib/apache-jsp-9.3.9.v20160517.jar:/home/picuy/minifi-0.1.0/./lib/nifi-persistent-provenance-repository-1.1.0.jar:/home/picuy/minifi-0.1.0/./lib/javax.el-api-3.0.0.jar:/home/picuy/minifi-0.1.0/./lib/jetty-jsp-jdt-2.3.3.jar:/home/picuy/minifi-0.1.0/./lib/minifi-framework-core-0.1.0.jar:/home/picuy/minifi-0.1.0/./lib/nifi-socket-utils-1.1.0.jar:/home/picuy/minifi-0.1.0/./lib/javax.json-1.0.4.jar:/home/picuy/minifi-0.1.0/./lib/nifi-ssl-context-service-api-1.1.0.jar:/home/picuy/minifi-0.1.0/./lib/nifi-user-actions-1.1.0.jar:/home/picuy/minifi-0.1.0/./lib/logback-core-1.1.7.jar:/home/picuy/minifi-0.1.0/./lib/jasypt-1.9.2.jar:/home/picuy/minifi-0.1.0/./lib/nifi-processor-utils-1.1.0.jar:/home/picuy/minifi-0.1.0/./lib/nifi-logging-utils-1.1.0.jar:/home/picuy/minifi-0.1.0/./lib/nifi-administration-1.1.0.jar:/home/picuy/minifi-0.1.0/./lib/httpcore-4.4.1.jar:/home/picuy/minifi-0.1.0/./lib/minifi-runtime-0.1.0.jar:/home/picuy/minifi-0.1.0/./lib/jackson-databind-2.6.1.jar:/home/picuy/minifi-0.1.0/./lib/quartz-2.2.1.jar:/home/picuy/minifi-0.1.0/./lib/apache-el-8.0.33.jar:/home/picuy/minifi-0.1.0/./lib/jetty-continuation-9.3.9.v20160517.jar:/home/picuy/minifi-0.1.0/./lib/commons-logging-1.2.jar:/home/picuy/minifi-0.1.0/./lib/nifi-framework-cluster-protocol-1.1.0.jar:/home/picuy/minifi-0.1.0/./lib/javax.servlet.jsp-api-2.3.1.jar:/home/picuy/minifi-0.1.0/./lib/javax.json-api-1.0.jar:/home/picuy/minifi-0.1.0/./lib/nifi-client-dto-1.1.0.jar:/home/picuy/minifi-0.1.0/./lib/nifi-framework-core-api-1.1.0.jar:/home/picuy/minifi-0.1.0/./lib/asm-1.0.2.jar:/home/picuy/minifi-0.1.0/./lib/json-smart-2.1.1.jar:/home/picuy/minifi-0.1.0/./lib/javax.servlet.jsp-2.3.2.jar:/home/picuy/minifi-0.1.0/./lib/asm-3.3.1.jar:/home/picuy/minifi-0.1.0/./lib/javax.el-3.0.1-b08.jar:/home/picuy/minifi-0.1.0/./lib/jackson-xc-1.9.2.jar:/home/picuy/minifi-0.1.0/./lib/slf4j-api-1.7.12.jar:/home/picuy/minifi-0.1.0/./lib/minifi-nar-utils-0.1.0.jar:/home/picuy/minifi-0.1.0/./lib/jersey-json-1.19.jar:/home/picuy/minifi-0.1.0/./lib/nifi-schema-utils-1.1.0.jar:/home/picuy/minifi-0.1.0/./lib/jackson-mapper-asl-1.9.13.jar:/home/picuy/minifi-0.1.0/./lib/logback-classic-1.1.7.jar:/home/picuy/minifi-0.1.0/./lib/minifi-utils-0.1.0.jar:/home/picuy/minifi-0.1.0/./lib/jettison-1.1.jar:/home/picuy/minifi-0.1.0/./lib/bcprov-jdk15on-1.54.jar:/home/picuy/minifi-0.1.0/./lib/javax.servlet.jsp.jstl-api-1.2.1.jar:/home/picuy/minifi-0.1.0/./lib/jetty-http-9.3.9.v20160517.jar:/home/picuy/minifi-0.1.0/./lib/nifi-expression-language-1.1.0.jar:/home/picuy/minifi-0.1.0/./lib/jetty-io-9.3.9.v20160517.jar:/home/picuy/minifi-0.1.0/./lib/jackson-core-2.6.1.jar:/home/picuy/minifi-0.1.0/./lib/nifi-utils-1.1.0.jar:/home/picuy/minifi-0.1.0/./lib/bcpkix-jdk15on-1.54.jar:/home/picuy/minifi-0.1.0/./lib/nifi-write-ahead-log-1.1.0.jar:/home/picuy/minifi-0.1.0/./lib/jackson-core-asl-1.9.13.jar -Dorg.apache.jasper.compiler.disablejsr199=true -Xmx256m -Xms256m -Dsun.net.http.allowRestrictedHeaders=true -Djava.net.preferIPv4Stack=true -Djava.awt.headless=true -Djava.protocol.handler.pkgs=sun.net.www.protocol -Dnifi.properties.file.path=/home/picuy/minifi-0.1.0/./conf/nifi.properties -Dnifi.bootstrap.listen.port=38084 -Dapp=MiNiFi -Dorg.apache.nifi.minifi.bootstrap.config.log.dir=/home/picuy/minifi-0.1.0/logs org.apache.nifi.minifi.MiNiFi<br />
[/code]</p>
<h2>4. Conclusions.</h2>
<ul>
<li>You can see the really value of using Ansible when you are provisioning multiple devices. Just execute Ansible command to start performing Linux command and create your own Ansible Playbooks to provision software like Kismet and MiNiFi.</li>
<li>Remember I never provisioned / installed an Ansible agent in the Device side, just download my Playbooks in my PC and ready !.</li>
<li>For other side you can tweak your Playbooks in order to deploy your services with restricted Linux privileged users. That is required when you are doing Automation in a constrained / restricted devices or VMs.</li>
<li>The Kismet and MiNiFi Ansible Playbooks are ready to be used in a PoC, but I don't recommend to use it in PROD because they need to be improved. For example I have to:
<ul>
<li>Implement them as Ansible Roles.</li>
<li>Implement Ansible Tasks to start Kismet and MiNiFi as <code>systemd</code> services with restricted Linux user, no <code>root</code>.</li>
<li>Implement Ansible Tasks to read and send in batch the logs or event files for Kismet and MiNiFi to external system as Syslog Server or Solr or Elasticsearch.</li>
</ul>
</li>
</ul>
<p>In the next blog post I will explain how to integrate/connect each Raspberry Pi (Kismet and MiNiFi) to a centralized Apache NiFi by using Ansible, of course!.</p>
<h2>5. References.</h2>
<p>Using Ansible with Raspberry Pi cluster.<br />
http://www.pidramble.com</p>
<p>Setup a Headless Raspberry Pi with Raspbian Jessie on OS X.<br />
http://blog.smalleycreative.com/linux/setup-a-headless-raspberry-pi-with-raspbian-jessie-on-os-x/</p>
<p>macOS Sierra SSH “Permission Denied”.<br />
https://rolfje.wordpress.com/2016/11/12/macos-sierra-ssh-permission-denied/</p>
