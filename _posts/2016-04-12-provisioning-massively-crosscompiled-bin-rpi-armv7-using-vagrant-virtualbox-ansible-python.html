---
layout: post
title: Provisioning massively cross-compiled binaries to Raspberry Pi (arm) using
  Vagrant, VirtualBox, Ansible and Python
date: 2016-04-12 17:46:31.000000000 +02:00
type: post
parent_id: '0'
published: true
password: ''
status: publish
categories:
- DevOps
- IoT
- Linux
tags:
- Ansible
- ARM
- Python
- Raspberry Pi
- Vagrant
meta:
  _wpcom_is_markdown: '1'
  _edit_last: '578869'
  _oembed_15b61e82ab1b94b98ac770b10928dc5e: "{{unknown}}"
  _oembed_868eda38880d53a751ae54b8b5fd7e48: "{{unknown}}"
  geo_public: '0'
  _publicize_job_id: '21716636012'
  _oembed_fe0927127f443d79765a25775e5c4693: "{{unknown}}"
  publicize_google_plus_url: https://plus.google.com/+RogerCarhuatocto/posts/3u1XhpiyD4j
  _publicize_done_5110107: '1'
  _wpas_done_5053089: '1'
  _publicize_done_external: a:1:{s:7:"twitter";a:1:{i:13849;s:54:"https://twitter.com/Chilcano/status/719929746453241857";}}
  _publicize_done_17477: '1'
  _wpas_done_13849: '1'
  publicize_twitter_user: Chilcano
  _oembed_76c6da8e3187d419b6dcc51d42a68a11: "{{unknown}}"
  _oembed_86d74a69af3db2c4f532a950e83a6557: "{{unknown}}"
  _oembed_70fa7f29806226940484ce9b70b4121c: "{{unknown}}"
  _oembed_be92a50004ded3a2aeb0c3e415461dcd: "{{unknown}}"
  _oembed_f5ffdb1ccbb2b62751e40b72f377a3bd: "{{unknown}}"
  _oembed_ba5b1f9ac5401566c2c26ed9077a7525: "{{unknown}}"
  _oembed_d7abb0c4ab86146e5d6b14bd5145fa84: "{{unknown}}"
  _oembed_0db9f03e014bba42cfa0a3e1016a4997: "{{unknown}}"
  _oembed_582a7dd25cefa1be3cf68c647522e20c: "{{unknown}}"
  _oembed_7adbec8a97bc668057c01970a8d33506: "{{unknown}}"
  _oembed_439f20bb738c2fb78a5aff3efecf16e1: "{{unknown}}"
  _oembed_1abd8381b725b40db4c90da5740fdee0: "{{unknown}}"
  _oembed_d301c9cb1a268cde018ca3b12296c0d3: "{{unknown}}"
  _wpas_skip_5053092: '1'
  _oembed_05f87f7fdb8e25a7d1265e3ff1b076ae: "{{unknown}}"
  _oembed_9df507a2f96735a854630464cbf0c59e: "{{unknown}}"
author:
  login: rcarhuatocto
  email: roger@intix.info
  display_name: Roger CARHUATOCTO
  first_name: ''
  last_name: ''
permalink: "/2016/04/12/provisioning-massively-crosscompiled-bin-rpi-armv7-using-vagrant-virtualbox-ansible-python/"
---
<p>If you are involved in an IoT or Mobile Application provisioning Project you probably need build a mechanism to spread your application binaries to all Devices on stock and to all the rolled out Devices.</p>
<p>With this Proof-of-concept I will shown you how to build the app binary provisioning system for your custom platform, in this case I'm going to use Raspberry Pi (ARM processor) quickly avoiding perform unnecessary tasks and providing also an ARM cross-compiling platform.</p>
<p><img src="{{ site.baseurl }}/assets/blog-cross-compiling-kismet-raspberrypi-arm.png" alt="blog-cross-compiling-kismet-raspberrypi-arm.png" /></p>

<p><!-- more --></p>

<p>To implement this I will use Vagrant to create an Ubuntu VM mounts the Raspbian OS image internally ready to be used for ARM cross-compiling. There is a special part in this blog post where explains how to NFS mount to provide remote booting for all Raspberry Pi's connected to same network.</p>
<p>I provide a new Github repository with all the updated scripts required for this PoC. You can download from here:<br />
I would like to mention that this work is based on <code>https://github.com/twobitcircus/rpi-build-and-boot</code> where I've created a Vagrantfile for VirtualBox, tweaked the Ansible Playbook and I have documented the process I've followed to make it work successfully in my environment (VirtualBox instead of Parallels and booting from NFS).</p>
<h2>Requirements:</h2>
<p>I'm using a Mac OS X (El Capitan - Version 10.11.3) with the next tools:</p>
<ul>
<li>VirtualBox 5.0.16</li>
<li>Vagrant 1.8.1</li>
<li>Ansible 2.0.1.0 (installed via Pip)</li>
<li>Python 2.7.11</li>
<li>Raspberry Pi 2 Model B </li>
<li>Raspbian OS (2015-09-24-raspbian-jessie.img)</li>
<li>OpenFramework for cross-compiling (http://openframeworks.cc)</li>
</ul>
<h3>Why <em>Ansible</em> instead of other configuration management tools ?</h3>
<p>Why Ansible (http://docs.ansible.com/ansible/intro_installation.html) instead of other configuration management tools as Puppet, Chef, ...?. Because, Ansible is simple and agentless; you can use it with just with a simple SSH terminal, nothing special is required to be installed in the Host, also because it is written in Python and as you have seen in my previous post, I'm using intensively Python and it is becoming my favorite programming language. You can install Ansible using the same Python installation tools and obviously, you can <code>import ansible</code> from your Python scripts.<br />
To install Ansible on Mac OS X (El Capitan - Version 10.11.3) is easy, just follow these steps:</p>
<p>[code lang=bash]<br />
$ sudo easy_install pip<br />
$ sudo pip install ansible --quiet</p>
<p>// upgrading Ansible and Pip<br />
$ sudo pip install ansible --upgrade<br />
$ sudo pip install --upgrade pip<br />
[/code]</p>
<h2>Preparing the Raspberry Pi</h2>
<p><strong>1. Copy RPi image to SD</strong></p>
<p>Identify the disk (not partition) of your SD card, unmount and copy the image there:</p>
<p>[code lang=bash]<br />
$ diskutil list<br />
$ diskutil unmountDisk /dev/disk2<br />
$ cd /Users/Chilcano/Downloads/@isos_vms/raspberrypi-imgs<br />
$ sudo dd bs=1m if=2015-09-24-raspbian-jessie.img of=/dev/rdisk2<br />
[/code]</p>
<p><strong>2. Connect the Raspberry Pi directly to your Host (MAC OS X)</strong></p>
<p>Using an ethernet cable, connect your Raspberry Pi to your Host, in my case I've a MAC OS X and I'm going to share my WIFI Network connection.<br />
Then, enabling <code>Internet Sharing</code> and the "Thunderbolt Ethernet" an IP address will be assigned to the Raspberry Pi, also Raspberry Pi will have Internet access/Network access and the MAC OS X can connect via SSH to the Raspberry Pi.<br />
All that will be possible without a hub, switch, router, screen or keyboard, etc. This will be useful, because we are going to install new software in Raspberry Pi.</p>
<p>After connect your Raspberry Pi to your MAC OS X, turn on by connecting an USB cable, in your MAC OS X open a Terminal and issue a SSH command, before re-generate the SSH keys.</p>
<p>Note that the default hostname of any Raspberry Pi is <code>raspberrypi.local</code>.</p>
<p>[code lang=bash]<br />
// cleaning existing keys<br />
$ ssh-keygen -R raspberrypi.local</p>
<p>// connect to RPi using `raspberry` as default password<br />
$ ssh pi@raspberrypi.local<br />
[/code]</p>
<p>After connecting, you will check the assigned IP address and the shared Internet Connection. Now, check out your connection.</p>
<p>[code lang=bash]<br />
pi@raspberrypi:~ $ ping www.docker.com<br />
PING www.docker.com (104.239.220.248) 56(84) bytes of data.<br />
64 bytes from 104.239.220.248: icmp_seq=1 ttl=49 time=212 ms<br />
64 bytes from 104.239.220.248: icmp_seq=2 ttl=49 time=214 ms<br />
^C<br />
--- www.docker.com ping statistics ---<br />
2 packets transmitted, 2 received, 0% packet loss, time 6970ms<br />
rtt min/avg/max/mdev = 207.205/213.294/217.893/3.513 ms<br />
[/code]</p>
<p><strong>3. Configure your RPi</strong></p>
<p>Boot your RPi and open a shell. Then enter:</p>
<p>[code lang=bash]<br />
pi@raspberrypi:~ $ sudo raspi-config<br />
[/code]</p>
<p>In the <code>raspi-config</code> menu, select <code>Option 1 Expand Filesystem</code>, change Keyboard layout, etc. and reboot.</p>
<p>Just if <code>mirrordirector.raspbian.org</code> mirror is not available, remove <code>http://mirrordirector.raspbian.org/raspbian/</code> repository and add a newest.</p>
<p>[code lang=bash]<br />
pi@raspberrypi ~ $ sudo nano /etc/apt/sources.list</p>
<p>#deb http://mirrordirector.raspbian.org/raspbian/ jessie main contrib non-free rpi<br />
deb http://ftp.cica.es/mirrors/Linux/raspbian/raspbian/ jessie main contrib non-free rpi</p>
<p># Uncomment line below then &#039;apt-get update&#039; to enable &#039;apt-get source&#039;<br />
#deb-src http://archive.raspbian.org/raspbian/ jessie main contrib non-free rpi<br />
[/code]</p>
<p><strong>4. Install OpenFrameworks tools and dependencies into Raspberry Pi</strong></p>
<p>Download and unzip OpenFrameworks into RPi under <code>/opt</code>.</p>
<p>[code lang=bash]<br />
pi@raspberrypi:~ $ cd /opt<br />
pi@raspberrypi:/opt $ sudo wget http://openframeworks.cc/versions/v0.9.0/of_v0.9.0_linuxarmv7l_release.tar.gz<br />
pi@raspberrypi:/opt $ sudo tar -zxf of_v0.9.0_linuxarmv7l_release.tar.gz<br />
pi@raspberrypi:/opt $ sudo rm of_v0.9.0_linuxarmv7l_release.tar.gz<br />
[/code]</p>
<p>Now, update the dependencies required when cross-compiling by running <code>install_dependencies.sh</code>.</p>
<p>[code lang=bash]<br />
pi@raspberrypi:~ $ sudo /opt/of_v0.9.0_linuxarmv7l_release/scripts/linux/debian/install_dependencies.sh<br />
[/code]</p>
<p>Now, compile oF, compile and execute an oF example.</p>
<p>[code lang=bash]<br />
// compiling oF<br />
pi@raspberrypi:~ $ sudo make Release -C /opt/of_v0.9.0_linuxarmv7l_release/libs/openFrameworksCompiled/project<br />
...<br />
se/libs/openFrameworksCompiled/lib/linuxarmv7l/obj/Release/libs/openFrameworks/math/ofMatrix4x4.o /opt/of_v0.9.0_linuxarmv7l_release/libs/openFrameworksCompiled/lib/linuxarmv7l/obj/Release/libs/openFrameworks/math/ofQuaternion.o /opt/of_v0.9.0_linuxarmv7l_release/libs/openFrameworksCompiled/lib/linuxarmv7l/obj/Release/libs/openFrameworks/math/ofVec2f.o<br />
HOST_OS=Linux<br />
HOST_ARCH=armv7l<br />
checking pkg-config libraries:   cairo zlib gstreamer-app-1.0 gstreamer-1.0 gstreamer-video-1.0 gstreamer-base-1.0 libudev freetype2 fontconfig sndfile openal openssl libpulse-simple alsa gtk+-3.0<br />
Done!<br />
make: Leaving directory &#039;/opt/of_v0.9.0_linuxarmv7l_release/libs/openFrameworksCompiled/project&#039;</p>
<p>// executing an example<br />
pi@raspberrypi:~ $ sudo make -C /opt/of_v0.9.0_linuxarmv7l_release/apps/myApps/emptyExample<br />
pi@raspberrypi:~ $ cd /opt/of_v0.9.0_linuxarmv7l_release/apps/myApps/emptyExample<br />
pi@raspberrypi /opt/of_v0.9.0_linuxarmv7l_release/apps/myApps/emptyExample $ bin/emptyExample<br />
[/code]</p>
<p><strong>5. Make an new image file from the existing and updated Raspberry Pi</strong></p>
<p>Remove the SD card from the Raspberry Pi, insert the  SD card in your Host (in my case is MAC OS X) and use <code>dd</code> to make an new image file.</p>
<p>[code lang=bash]<br />
$ diskutil list<br />
$ diskutil unmountDisk /dev/disk2<br />
$ sudo dd bs=1m if=/dev/rdisk2 of=2015-09-24-raspbian-jessie-of2.img</p>
<p>15279+0 records in<br />
15279+0 records out<br />
16021192704 bytes transferred in 381.968084 secs (41943799 bytes/sec)<br />
[/code]</p>
<p><em>Very important</em>:</p>
<ul>
<li>The <code>2015-09-24-raspbian-jessie-of.img</code> will be <code>shared</code> and after <code>mounted</code> from the guest VM, for that, set the user and permissions to <code>2015-09-24-raspbian-jessie-of.img</code> as shown below:</li>
</ul>
<p>[code lang=bash]<br />
$ sudo chmod +x 2015-09-24-raspbian-jessie-of2.img<br />
$ sudo chown Chilcano 2015-09-24-raspbian-jessie-of2.img</p>
<p>$ ls -la<br />
total 110439056<br />
drwxr-xr-x  33 Chilcano  staff         1122 Apr 11 19:12 ./<br />
drwxr-xr-x  35 Chilcano  staff         1190 Mar 23 19:26 ../<br />
-rwxr-xr-x   1 Chilcano  staff  16021192704 Apr 11 17:29 2015-09-24-raspbian-jessie-of1.img*<br />
-rwxr-xr-x   1 Chilcano  staff  16021192704 Apr 11 19:19 2015-09-24-raspbian-jessie-of2.img*<br />
-rwxr-xr-x   1 Chilcano  staff   4325376000 Apr 11 17:02 2015-09-24-raspbian-jessie.img*<br />
-rwxr-xr-x   1 Chilcano  staff  16021192704 Mar 31 12:31 2016-03-18-raspbian-jessie-of1.img*<br />
-rwxr-xr-x   1 Chilcano  staff   4033871872 Apr  5 16:31 2016-03-18-raspbian-jessie.img*<br />
...<br />
[/code]</p>
<h2>Building the Vagrant box</h2>
<p><strong>1. In your MAC OS X, to clone the <code>rpi-build-and-boot</code> github repository</strong></p>
<p>[code lang=bash]<br />
$ git clone https://github.com/twobitcircus/rpi-build-and-boot<br />
$ cd rpi-build-and-boot<br />
[/code]</p>
<p>Copy/Move the newest RPi image created above into <code>rpi-build-and-boot</code> folder.</p>
<p>[code lang=bash]<br />
$ mv /Users/Chilcano/Downloads/@isos_vms/raspberrypi-imgs/2015-09-24-raspbian-jessie-of2.img .<br />
[/code]</p>
<p><strong>2. Install Vagrant and vbguest plugin into MAC OS X</strong></p>
<p>[code lang=bash]<br />
$ wget https://releases.hashicorp.com/vagrant/1.8.1/vagrant_1.8.1.dmg<br />
$ vagrant plugin install vagrant-vbguest<br />
[/code]</p>
<p><strong>3. Create a new <code>Vagrantfile</code> with VirtualBox as provider in the same folder <code>rpi-build-and-boot</code></strong></p>
<p>[code lang=ruby]<br />
# -*- mode: ruby -*-<br />
# vi: set ft=ruby :</p>
<p>Vagrant.configure(2) do |config|<br />
  # https://atlas.hashicorp.com/ubuntu/boxes/trusty64 [Official Ubuntu Server 14.04 LTS (Trusty Tahr) builds]<br />
  config.vm.box = &quot;ubuntu/trusty64&quot;<br />
  config.vm.provider &quot;virtualbox&quot; do |vb|<br />
    config.vbguest.auto_update = true<br />
    vb.customize [&quot;modifyvm&quot;, :id, &quot;--memory&quot;, &quot;6144&quot;]<br />
    vb.customize [&quot;modifyvm&quot;, :id, &quot;--cpus&quot;, &quot;4&quot;]<br />
  end<br />
  # If you want to use this system to netboot Raspberry Pi, then uncomment this line<br />
  #config.vm.network &quot;public_network&quot;, bridge: &quot;en4: mac-eth0&quot;, ip: &quot;10.0.0.1&quot;<br />
  config.vm.network &quot;public_network&quot;, bridge: &quot;ask&quot;, ip: &quot;10.0.0.1&quot;<br />
  config.vm.provision &quot;ansible&quot; do |ansible|<br />
    ansible.playbook = &quot;playbook.yml&quot;<br />
  end<br />
end<br />
[/code]</p>
<p><strong>4. Getting <code>boot</code> and <code>root</code> partitions offsets to do loop mounting in Vagrant</strong></p>
<p>Using <code>./tool.py offsets</code> I will get the offsets of the <code>boot</code> and <code>root</code> partitions, after getting offset, copy the output of this tool to the top of <code>playbook.yml</code>.<br />
To run <code>tool.py</code> in MAC OS X, you will need <code>Python</code> configured.</p>
<p>[code lang=bash]<br />
$ ./tool.py offsets 2015-09-24-raspbian-jessie-of2.img</p>
<p>    image: 2015-09-24-raspbian-jessie-of2.img<br />
    offset_boot: 4194304<br />
    offset_root: 62914560<br />
[/code]</p>
<p>The idea to loop-mount the RPi image is to create a full structure of directories and files of a Raspberry Pi distribution under a mounting-point in a Vagrant box. This structure is required to do <code>cross-compiling</code> and move/copy new binaries and ARM cross-compiled binaries.</p>
<p><strong>5. Mounting Raspberry Pi image and booting from Vagrant using NFS</strong></p>
<p>Using <code>./tool.py netboot image.img /dev/rdiskX [--ip=10.0.0.Y]</code> you will copy just the <code>boot</code> partition in a new and tiny SD card.<br />
This new SD card with a fresh <code>boot</code> partition will be useful to boot from the network/remotely. The RPi will download the <code>root</code> partition from Vagrant, in fact, Vagrant will be sharing the custom RPi image (<code>2015-09-24-raspbian-jessie-of2.img</code>) via NFS to any Raspberry Pi connected to same network and having a pre-loaded <code>boot</code> partition.</p>
<p>The idea behind is to provision a custom RPi image massively avoiding to waste time copying and creating SD card for each Raspberry Pi. Also, this method is useful to provision software, configuration, packages, or in my case, provide cross-compiled software for ARM architectures massively.</p>
<p>[code lang=bash]<br />
$ diskutil list</p>
<p>// a new SD on disk3 will be used<br />
$ diskutil unmountDisk /dev/disk3</p>
<p>$ ./tool.py netboot 2015-09-24-raspbian-jessie-of2.img /dev/rdisk3</p>
<p>2015-09-24-raspbian-jessie-of2.img /dev/rdisk3 10.0.0.101<br />
The following partitions will be destroyed<br />
/dev/disk3 (external, physical):<br />
   #:                       TYPE NAME                    SIZE       IDENTIFIER<br />
   0:     FDisk_partition_scheme                        *4.0 GB     disk3<br />
   1:             Windows_FAT_32 boot                    58.7 MB    disk3s1<br />
   2:                      Linux                         3.9 GB     disk3s2</p>
<p>are you sure? y<br />
OK<br />
Unmount of all volumes on disk3 was successful<br />
sudo dd if=2015-09-24-raspbian-jessie-of2.img of=/dev/rdisk3 bs=62914560 count=1<br />
Password:<br />
1+0 records in<br />
1+0 records out<br />
62914560 bytes transferred in 6.846875 secs (9188799 bytes/sec)<br />
Disk /dev/rdisk3 ejected<br />
[/code]</p>
<p>Note that <code>tool.py netboot</code> automatically will assigns to RPi the <code>10.0.0.101</code> as IP address and <code>8.8.8.8</code> and <code>8.8.4.4</code> as DNS servers to <code>eth0</code>.<br />
You can check or modify previously these values by editing the <code>cmdline.txt</code> file placed in the <code>boot</code> RPi partition. You can edit it from a running Raspberry Pi or from a mounted partition.</p>
<p><strong>6. Download and unzip oF (OpenFramework) into <code>rpi-build-and-boot</code> folder</strong></p>
<p>If you forgot copy OpenFramework in your RPi, you can do now. Using the Ansible <code>playbook.yml</code>, the <code>oF</code> will be copied to your RPi.</p>
<p>[code lang=bash]<br />
$ cd rpi-build-and-boot<br />
$ wget http://openframeworks.cc/versions/v0.9.0/of_v0.9.0_linuxarmv7l_release.tar.gz<br />
$ tar -zxf of_v0.9.0_linuxarmv7l_release.tar.gz<br />
[/code]</p>
<p><strong>7. Update the Ansible <code>playbook.yml</code></strong></p>
<p>I've had to tweak the <code>playbook.yml</code> to avoid warnings, add DNS to <code>cmdline.txt</code> and add <code>iptables</code> filters to get Internet access on RPi using Host shared NIC. Here the updated Ansible <code>playbook.yml</code>:</p>
<p>[code lang=python]<br />
---<br />
- hosts: all<br />
  remote_user: vagrant<br />
  become: yes<br />
  become_method: sudo<br />
  vars:<br />
    of_version: of_v0.9.0_linuxarmv7l_release<br />
    raspbian_image: 2015-09-24-raspbian-jessie-of2.img<br />
    offset_boot: 4194304<br />
    offset_root: 62914560<br />
  tasks:<br />
    - apt: upgrade=dist update_cache=yes<br />
    - file: path=/opt/raspberrypi state=directory</p>
<p>    - apt: name=nfs-kernel-server<br />
    - lineinfile: dest=/etc/exports line=&quot;/opt/raspberrypi/root 10.0.0.0/24(rw,sync,no_root_squash,no_subtree_check)&quot;</p>
<p>    - lineinfile: dest=/etc/cron.d/opt_raspberrypi_root line=&quot;* * * * * root /bin/mount /opt/raspberrypi/root&quot; create=yes</p>
<p>    - service: name=nfs-kernel-server state=restarted</p>
<p>    - apt: name=build-essential<br />
    - apt: name=pkg-config<br />
    - apt: name=git<br />
    - apt: name=python-pip<br />
    - apt: name=python-dev<br />
    - apt: name=unzip<br />
    - apt: name=gawk<br />
    - apt: name=libudev-dev</p>
<p>    - apt: name=sshpass</p>
<p>    - pip: name=ansible<br />
    - pip: name=paramiko<br />
    - pip: name=PyYAML<br />
    - pip: name=jinja2<br />
    - pip: name=httplib2</p>
<p>    - apt: name=tinyproxy<br />
    - lineinfile: dest=&quot;/etc/tinyproxy.conf&quot; line=&quot;Allow 10.0.0.0/8&quot;<br />
    - service: name=tinyproxy state=restarted</p>
<p>    - file: path=/opt/raspberrypi/boot state=directory<br />
    - file: path=/opt/raspberrypi/root state=directory</p>
<p>    - mount: src=&quot;/vagrant/{{raspbian_image}}&quot; name=&quot;/opt/raspberrypi/boot&quot; fstype=&quot;auto&quot;  opts=&quot;loop,offset={{offset_boot}},noauto&quot; state=&quot;mounted&quot;<br />
    - mount: src=&quot;/vagrant/{{raspbian_image}}&quot; name=&quot;/opt/raspberrypi/root&quot; fstype=&quot;auto&quot;  opts=&quot;loop,offset={{offset_root}},noauto&quot; state=&quot;mounted&quot;<br />
    - lineinfile: dest=/etc/rc.local line=&quot;mount /opt/raspberrypi/root&quot; insertbefore=&quot;exit 0&quot;<br />
    - lineinfile: dest=/etc/rc.local line=&quot;mount /opt/raspberrypi/boot&quot; insertbefore=&quot;exit 0&quot;</p>
<p>    # the rpi is unbootable unless it is told not to mount the root filesystem from the card!. also added dns to cmdline.txt and iptables filter.<br />
    - lineinfile: dest=/opt/raspberrypi/root/etc/fstab regexp=&quot;^\/dev\/mmcblk0p2&quot; state=&quot;absent&quot;<br />
    - replace: dest=/opt/raspberrypi/boot/cmdline.txt regexp=&quot;rootwait$&quot; replace=&quot;dwc_otg.lpm_enable=0 console=ttyAMA0,115200 kgdboc=ttyAMA0,115200 console=tty1 elevator=deadline root=/dev/nfs rootfstype=nfs nfsroot=10.0.0.1:/opt/raspberrypi/root,udp,vers=3 rw fsck.repair=no rootwait ip=10.0.0.101:10.0.0.1:10.0.0.1:255.255.255.0:rpi:eth0:off:8.8.4.4:8.8.8.8 smsc95xx.turbo_mode=N&quot; backup=&quot;no&quot;</p>
<p>    # build helpies<br />
    - file: path=/opt/RPI_BUILD_ROOT state=directory<br />
    - file: src=/opt/raspberrypi/root/etc dest=/opt/RPI_BUILD_ROOT/etc state=link<br />
    - file: src=/opt/raspberrypi/root/lib dest=/opt/RPI_BUILD_ROOT/lib state=link<br />
    - file: src=/opt/raspberrypi/root/opt dest=/opt/RPI_BUILD_ROOT/opt state=link<br />
    - command: rsync -avz /opt/raspberrypi/root/usr/ /opt/RPI_BUILD_ROOT/usr</p>
<p>    - file: src=/opt/raspberrypi/root/lib/arm-linux-gnueabihf/libanl.so.1           dest=/opt/raspberrypi/root/usr/lib/arm-linux-gnueabihf/libanl.so state=link<br />
    - file: src=/opt/raspberrypi/root/lib/arm-linux-gnueabihf/libBrokenLocale.so.1  dest=/opt/raspberrypi/root/usr/lib/arm-linux-gnueabihf/libBrokenLocale.so state=link<br />
    - file: src=/opt/raspberrypi/root/lib/arm-linux-gnueabihf/libcidn.so.1          dest=/opt/raspberrypi/root/usr/lib/arm-linux-gnueabihf/libcidn.so state=link<br />
    - file: src=/opt/raspberrypi/root/lib/arm-linux-gnueabihf/libcrypt.so.1         dest=/opt/raspberrypi/root/usr/lib/arm-linux-gnueabihf/libcrypt.so state=link<br />
    - file: src=/opt/raspberrypi/root/lib/arm-linux-gnueabihf/libdbus-1.so.3.8.13   dest=/opt/raspberrypi/root/usr/lib/arm-linux-gnueabihf/libdbus-1.so state=link<br />
    - file: src=/opt/raspberrypi/root/lib/arm-linux-gnueabihf/libdl.so.2            dest=/opt/raspberrypi/root/usr/lib/arm-linux-gnueabihf/libdl.so state=link<br />
    - file: src=/opt/raspberrypi/root/lib/arm-linux-gnueabihf/libexpat.so.1.6.0     dest=/opt/raspberrypi/root/usr/lib/arm-linux-gnueabihf/libexpat.so state=link<br />
    - file: src=/opt/raspberrypi/root/lib/arm-linux-gnueabihf/libglib-2.0.so.0      dest=/opt/raspberrypi/root/usr/lib/arm-linux-gnueabihf/libglib-2.0.so state=link<br />
    - file: src=/opt/raspberrypi/root/lib/arm-linux-gnueabihf/liblzma.so.5.0.0      dest=/opt/raspberrypi/root/usr/lib/arm-linux-gnueabihf/liblzma.so state=link<br />
    - file: src=/opt/raspberrypi/root/lib/arm-linux-gnueabihf/libm.so.6             dest=/opt/raspberrypi/root/usr/lib/arm-linux-gnueabihf/libm.so state=link<br />
    - file: src=/opt/raspberrypi/root/lib/arm-linux-gnueabihf/libnsl.so.1           dest=/opt/raspberrypi/root/usr/lib/arm-linux-gnueabihf/libnsl.so state=link<br />
    - file: src=/opt/raspberrypi/root/lib/arm-linux-gnueabihf/libnss_compat.so.2    dest=/opt/raspberrypi/root/usr/lib/arm-linux-gnueabihf/libnss_compat.so state=link<br />
    - file: src=/opt/raspberrypi/root/lib/arm-linux-gnueabihf/libnss_dns.so.2       dest=/opt/raspberrypi/root/usr/lib/arm-linux-gnueabihf/libnss_dns.so state=link<br />
    - file: src=/opt/raspberrypi/root/lib/arm-linux-gnueabihf/libnss_files.so.2     dest=/opt/raspberrypi/root/usr/lib/arm-linux-gnueabihf/libnss_files.so state=link<br />
    - file: src=/opt/raspberrypi/root/lib/arm-linux-gnueabihf/libnss_hesiod.so.2    dest=/opt/raspberrypi/root/usr/lib/arm-linux-gnueabihf/libnss_hesiod.so state=link<br />
    - file: src=/opt/raspberrypi/root/lib/arm-linux-gnueabihf/libnss_nisplus.so.2   dest=/opt/raspberrypi/root/usr/lib/arm-linux-gnueabihf/libnss_nisplus.so state=link<br />
    - file: src=/opt/raspberrypi/root/lib/arm-linux-gnueabihf/libnss_nis.so.2       dest=/opt/raspberrypi/root/usr/lib/arm-linux-gnueabihf/libnss_nis.so state=link<br />
    - file: src=/opt/raspberrypi/root/lib/arm-linux-gnueabihf/libpcre.so.3          dest=/opt/raspberrypi/root/usr/lib/arm-linux-gnueabihf/libpcre.so state=link<br />
    - file: src=/opt/raspberrypi/root/lib/arm-linux-gnueabihf/libpng12.so.0         dest=/opt/raspberrypi/root/usr/lib/arm-linux-gnueabihf/libpng12.so.0 state=link<br />
    - file: src=/opt/raspberrypi/root/lib/arm-linux-gnueabihf/libresolv.so.2        dest=/opt/raspberrypi/root/usr/lib/arm-linux-gnueabihf/libresolv.so state=link<br />
    - file: src=/opt/raspberrypi/root/lib/arm-linux-gnueabihf/libthread_db.so.1     dest=/opt/raspberrypi/root/usr/lib/arm-linux-gnueabihf/libthread_db.so state=link<br />
    - file: src=/opt/raspberrypi/root/lib/arm-linux-gnueabihf/libusb-0.1.so.4       dest=/opt/raspberrypi/root/usr/lib/arm-linux-gnueabihf/libusb-0.1.so.4 state=link<br />
    - file: src=/opt/raspberrypi/root/lib/arm-linux-gnueabihf/libusb-1.0.so.0.1.0   dest=/opt/raspberrypi/root/usr/lib/arm-linux-gnueabihf/libusb-1.0.so state=link<br />
    - file: src=/opt/raspberrypi/root/lib/arm-linux-gnueabihf/libutil.so.1          dest=/opt/raspberrypi/root/usr/lib/arm-linux-gnueabihf/libutil.so state=link<br />
    - file: src=/opt/raspberrypi/root/lib/arm-linux-gnueabihf/libz.so.1.2.8         dest=/opt/raspberrypi/root/usr/lib/arm-linux-gnueabihf/libz.so state=link<br />
    - file: src=/opt/raspberrypi/root/lib/arm-linux-gnueabihf/libudev.so.1.5.0      dest=/opt/raspberrypi/root/usr/lib/arm-linux-gnueabihf/libudev.so state=link</p>
<p>    - file: path=/tmp/CROSS_BUILD_TOOLS state=directory<br />
    - copy: src=build_cross_gcc.sh dest=/tmp/CROSS_BUILD_TOOLS/build_cross_gcc.sh mode=0744<br />
    - shell: /tmp/CROSS_BUILD_TOOLS/build_cross_gcc.sh chdir=/tmp/CROSS_BUILD_TOOLS creates=/opt/cross/bin/arm-linux-gnueabihf-g++</p>
<p>    - lineinfile: dest=&quot;/home/vagrant/.profile&quot; line=&quot;export GST_VERSION=1.0&quot;<br />
    - lineinfile: dest=&quot;/home/vagrant/.profile&quot; line=&quot;export RPI_ROOT=/opt/raspberrypi/root&quot;<br />
    #######- lineinfile: dest=&quot;/home/vagrant/.profile&quot; line=&quot;export RPI_BUILD_ROOT=/opt/RPI_BUILD_ROOT&quot;<br />
    - lineinfile: dest=&quot;/home/vagrant/.profile&quot; line=&quot;export TOOLCHAIN_ROOT=/opt/cross/bin&quot;<br />
    - lineinfile: dest=&quot;/home/vagrant/.profile&quot; line=&quot;export PLATFORM_OS=Linux&quot;<br />
    - lineinfile: dest=&quot;/home/vagrant/.profile&quot; line=&quot;export PLATFORM_ARCH=armv7l&quot;<br />
    - lineinfile: dest=&quot;/home/vagrant/.profile&quot; line=&quot;export PKG_CONFIG_PATH=$RPI_ROOT/usr/lib/arm-linux-gnueabihf/pkgconfig:$RPI_ROOT/usr/share/pkgconfig:$RPI_ROOT/usr/lib/pkgconfig&quot;</p>
<p>    - unarchive: src={{of_version}}.tar.gz dest=/opt/raspberrypi/root/opt creates=/opt/raspberrypi/root/opt/{{of_version}}<br />
    - file: src={{of_version}} dest=/opt/raspberrypi/root/opt/openframeworks state=link<br />
    - file: src=/opt/raspberrypi/root/opt/openframeworks dest=/opt/openframeworks state=link<br />
    - command: chown -R vagrant /opt/raspberrypi/root/opt/{{of_version}}</p>
<p>    # forwarding traffic from eth0 (internet) to eth1 (rpi connection) with iptables<br />
    - replace: dest=/etc/sysctl.conf regexp=&quot;^#net.ipv4.ip_forward=1$&quot; replace=&quot;net.ipv4.ip_forward=1&quot;<br />
    - shell: /bin/echo 1 &gt; /proc/sys/net/ipv4/ip_forward<br />
    - command: iptables -A FORWARD -o eth0 -i eth1 -m conntrack --ctstate NEW -j ACCEPT<br />
    - command: iptables -A FORWARD -m conntrack --ctstate ESTABLISHED,RELATED -j ACCEPT<br />
    - command: iptables -A POSTROUTING -t nat -j MASQUERADE<br />
    - shell: /sbin/iptables-save | /usr/bin/tee /etc/iptables.backup<br />
    - service: name=ufw state=restarted<br />
  handlers:</p>
<p>[/code]</p>
<p><strong>8. Create the Vagrant box</strong></p>
<p>[code lang=bash]<br />
$ cd rpi-build-and-boot<br />
$ vagrant up --provider virtualbox</p>
<p>Bringing machine &#039;default&#039; up with &#039;virtualbox&#039; provider...<br />
==&gt; default: Importing base box &#039;ubuntu/trusty64&#039;...<br />
==&gt; default: Matching MAC address for NAT networking...<br />
==&gt; default: Checking if box &#039;ubuntu/trusty64&#039; is up to date...<br />
==&gt; default: A newer version of the box &#039;ubuntu/trusty64&#039; is available! You currently<br />
==&gt; default: have version &#039;20160311.0.0&#039;. The latest is version &#039;20160406.0.0&#039;. Run<br />
==&gt; default: `vagrant box update` to update.<br />
==&gt; default: Setting the name of the VM: rpi-build-and-boot_default_1460455393206_79951<br />
==&gt; default: Clearing any previously set forwarded ports...<br />
==&gt; default: Clearing any previously set network interfaces...<br />
==&gt; default: Preparing network interfaces based on configuration...<br />
    default: Adapter 1: nat<br />
    default: Adapter 2: bridged<br />
==&gt; default: Forwarding ports...<br />
    default: 22 (guest) =&gt; 2222 (host) (adapter 1)<br />
...<br />
TASK [service] *****************************************************************<br />
changed: [default]</p>
<p>PLAY RECAP *********************************************************************<br />
default                    : ok=82   changed=76   unreachable=0    failed=0<br />
[/code]</p>
<p>... let&#039;s have coffee  ;)</p>
<p>After that, restart the Vagrant box recently created.</p>
<p>[code lang=bash]<br />
$ vagrant halt<br />
==&gt; default: Attempting graceful shutdown of VM...</p>
<p>$ vagrant up<br />
Bringing machine &#039;default&#039; up with &#039;virtualbox&#039; provider...<br />
==&gt; default: Checking if box &#039;ubuntu/trusty64&#039; is up to date...<br />
==&gt; default: A newer version of the box &#039;ubuntu/trusty64&#039; is available! You currently<br />
==&gt; default: have version &#039;20160311.0.0&#039;. The latest is version &#039;20160406.0.0&#039;. Run<br />
==&gt; default: `vagrant box update` to update.<br />
==&gt; default: Clearing any previously set forwarded ports...<br />
==&gt; default: Clearing any previously set network interfaces...<br />
==&gt; default: Specific bridge &#039;ask&#039; not found. You may be asked to specify<br />
==&gt; default: which network to bridge to.<br />
==&gt; default: Available bridged network interfaces:<br />
1) en0: Wi-Fi (AirPort)<br />
2) en1: Thunderbolt 1<br />
3) en2: Thunderbolt 2<br />
4) p2p0<br />
5) awdl0<br />
6) en4: mac-eth0<br />
==&gt; default: When choosing an interface, it is usually the one that is<br />
==&gt; default: being used to connect to the internet.<br />
    default: Which interface should the network bridge to? 6<br />
==&gt; default: Preparing network interfaces based on configuration...<br />
    default: Adapter 1: nat<br />
    default: Adapter 2: bridged<br />
==&gt; default: Forwarding ports...<br />
    default: 22 (guest) =&gt; 2222 (host) (adapter 1)<br />
==&gt; default: Running &#039;pre-boot&#039; VM customizations...<br />
==&gt; default: Booting VM...<br />
==&gt; default: Waiting for machine to boot. This may take a few minutes...<br />
    default: SSH address: 127.0.0.1:2222<br />
    default: SSH username: vagrant<br />
    default: SSH auth method: private key<br />
==&gt; default: Machine booted and ready!<br />
GuestAdditions 5.0.16 running --- OK.<br />
==&gt; default: Checking for guest additions in VM...<br />
==&gt; default: Configuring and enabling network interfaces...<br />
==&gt; default: Mounting shared folders...<br />
    default: /vagrant =&gt; /Users/Chilcano/1github-repo/rpi-build-and-boot<br />
==&gt; default: Machine already provisioned. Run `vagrant provision` or use the `--provision`<br />
==&gt; default: flag to force provisioning. Provisioners marked to run always will still run.<br />
[/code]</p>
<p>Connect your Raspberry Pi -with the SD card and boot partition copied- using ethernet clable to your Host PC (in my case is a Mac OS X), wait some seconds and check if Raspberry Pi has started from the <code>root</code> partition shared by NFS from the Vagrant box.</p>
<p>[code lang=bash]<br />
$ ping raspberrypi.local<br />
PING raspberrypi.local (10.0.0.101): 56 data bytes<br />
64 bytes from 10.0.0.101: icmp_seq=0 ttl=64 time=0.386 ms<br />
64 bytes from 10.0.0.101: icmp_seq=1 ttl=64 time=0.471 ms<br />
^C<br />
--- raspberrypi.local ping statistics ---<br />
2 packets transmitted, 2 packets received, 0.0% packet loss<br />
round-trip min/avg/max/stddev = 0.386/0.428/0.471/0.042 ms</p>
<p>Chilcano@Pisc0 : ~/1github-repo/rpi-build-and-boot<br />
$ ping 10.0.0.101<br />
PING 10.0.0.101 (10.0.0.101): 56 data bytes<br />
64 bytes from 10.0.0.101: icmp_seq=0 ttl=64 time=0.450 ms<br />
64 bytes from 10.0.0.101: icmp_seq=1 ttl=64 time=0.591 ms<br />
^C<br />
--- 10.0.0.101 ping statistics ---<br />
2 packets transmitted, 2 packets received, 0.0% packet loss<br />
round-trip min/avg/max/stddev = 0.450/0.520/0.591/0.071 ms<br />
[/code]</p>
<p>And check if Raspberry Pi is running but from Vagrant box.</p>
<p>[code lang=bash]<br />
$ vagrant ssh<br />
Welcome to Ubuntu 14.04.4 LTS (GNU/Linux 3.13.0-85-generic x86_64)</p>
<p> * Documentation:  https://help.ubuntu.com/</p>
<p>  System information as of Tue Apr 12 10:55:29 UTC 2016</p>
<p>  System load:  0.07               Processes:           129<br />
  Usage of /:   11.8% of 39.34GB   Users logged in:     0<br />
  Memory usage: 2%                 IP address for eth0: 10.0.2.15<br />
  Swap usage:   0%                 IP address for eth1: 10.0.0.1</p>
<p>  Graph this data and manage this system at:<br />
    https://landscape.canonical.com/</p>
<p>  Get cloud support with Ubuntu Advantage Cloud Guest:<br />
    http://www.ubuntu.com/business/services/cloud</p>
<p>Last login: Tue Apr 12 10:27:47 2016 from 10.0.2.2</p>
<p>vagrant@vagrant-ubuntu-trusty-64:~$ ifconfig<br />
eth0      Link encap:Ethernet  HWaddr 08:00:27:c9:24:d6<br />
          inet addr:10.0.2.15  Bcast:10.0.2.255  Mask:255.255.255.0<br />
          inet6 addr: fe80::a00:27ff:fec9:24d6/64 Scope:Link<br />
          UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1<br />
          RX packets:665 errors:0 dropped:0 overruns:0 frame:0<br />
          TX packets:427 errors:0 dropped:0 overruns:0 carrier:0<br />
          collisions:0 txqueuelen:1000<br />
          RX bytes:67162 (67.1 KB)  TX bytes:54225 (54.2 KB)</p>
<p>eth1      Link encap:Ethernet  HWaddr 08:00:27:b3:e9:a4<br />
          inet addr:10.0.0.1  Bcast:10.0.0.255  Mask:255.255.255.0<br />
          inet6 addr: fe80::a00:27ff:feb3:e9a4/64 Scope:Link<br />
          UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1<br />
          RX packets:29474 errors:0 dropped:0 overruns:0 frame:0<br />
          TX packets:60947 errors:0 dropped:0 overruns:0 carrier:0<br />
          collisions:0 txqueuelen:1000<br />
          RX bytes:5247033 (5.2 MB)  TX bytes:70887820 (70.8 MB)</p>
<p>lo        Link encap:Local Loopback<br />
          inet addr:127.0.0.1  Mask:255.0.0.0<br />
          inet6 addr: ::1/128 Scope:Host<br />
          UP LOOPBACK RUNNING  MTU:65536  Metric:1<br />
          RX packets:0 errors:0 dropped:0 overruns:0 frame:0<br />
          TX packets:0 errors:0 dropped:0 overruns:0 carrier:0<br />
          collisions:0 txqueuelen:0<br />
          RX bytes:0 (0.0 B)  TX bytes:0 (0.0 B)</p>
<p>vagrant@vagrant-ubuntu-trusty-64:~$ ping 10.0.0.101<br />
PING 10.0.0.101 (10.0.0.101) 56(84) bytes of data.<br />
64 bytes from 10.0.0.101: icmp_seq=1 ttl=64 time=0.536 ms<br />
64 bytes from 10.0.0.101: icmp_seq=2 ttl=64 time=0.745 ms<br />
64 bytes from 10.0.0.101: icmp_seq=3 ttl=64 time=0.910 ms<br />
^C<br />
--- 10.0.0.101 ping statistics ---<br />
3 packets transmitted, 3 received, 0% packet loss, time 1999ms<br />
rtt min/avg/max/mdev = 0.536/0.730/0.910/0.154 ms<br />
vagrant@vagrant-ubuntu-trusty-64:~$ ping google.com<br />
PING google.com (216.58.211.206) 56(84) bytes of data.<br />
64 bytes from mad01s25-in-f14.1e100.net (216.58.211.206): icmp_seq=1 ttl=63 time=14.1 ms<br />
64 bytes from mad01s25-in-f14.1e100.net (216.58.211.206): icmp_seq=2 ttl=63 time=13.5 ms<br />
64 bytes from mad01s25-in-f14.1e100.net (216.58.211.206): icmp_seq=3 ttl=63 time=13.9 ms<br />
^C<br />
--- google.com ping statistics ---<br />
3 packets transmitted, 3 received, 0% packet loss, time 2008ms<br />
rtt min/avg/max/mdev = 13.521/13.883/14.137/0.296 ms<br />
[/code]</p>
<p><strong>9. Check if ARM cross-compiling works in the VirtualBox guest</strong></p>
<p>Check if the cross-compiling Variables have been defined.</p>
<p>[code lang=bash]<br />
vagrant@vagrant-ubuntu-trusty-64:~$ cat /home/vagrant/.profile</p>
<p>...<br />
export GST_VERSION=1.0<br />
export RPI_ROOT=/opt/raspberrypi/root<br />
export TOOLCHAIN_ROOT=/opt/cross/bin<br />
export PLATFORM_OS=Linux<br />
export PLATFORM_ARCH=armv7l<br />
export PKG_CONFIG_PATH=$RPI_ROOT/usr/lib/arm-linux-gnueabihf/pkgconfig:$RPI_ROOT/usr/share/pkgconfig:$RPI_ROOT/usr/lib/pkgconfig<br />
[/code]</p>
<p>Check if RPi has been mounted.</p>
<p>[code lang=bash]<br />
vagrant@vagrant-ubuntu-trusty-64:~$ ll /opt/raspberrypi/boot/<br />
vagrant@vagrant-ubuntu-trusty-64:~$ ll /opt/raspberrypi/root/<br />
[/code]</p>
<p>And check if oF works by compiling an example.</p>
<p>[code lang=bash]<br />
$ make -C /opt/openframeworks/apps/myApps/emptyExample<br />
[/code]</p>
<h2>Conclusions</h2>
<ul>
<li>As you have seen above, using Vagrant, Ansible and Python you can build easily a Provisioning system for massive delivery of binaries/packages for Raspberry Pi or Mobile Devices.</li>
<li>Also, you could replace OpenFramework tool (http://openframeworks.cc) used for ARM cross-compiling for other similar Tool if you have different target Device, to do that, just modify the part related to that in the Ansible Playbook.</li>
</ul>
<p>Finally, in the next blog post, I will explain how to cross-compile the Kismet tool (https://www.kismetwireless.net/download.shtml) from source for Raspberry Pi (ARM).</p>
<p>I hope you have enjoyed.<br />
See you soon.</p>
<h2>References:</h2>
<ol>
<li>Loop-mounting partitions from a disk image:
<ul>
<li>http://www.andremiller.net/content/mounting-hard-disk-image-including-partitions-using-linux</li>
<li>http://madduck.net/blog/2006.10.20:loop-mounting-partitions-from-a-disk-image</li>
</ul>
</li>
<li>Ansible documentation:
<ul>
<li>http://docs.ansible.com/ansible</li>
</ul>
</li>
<li>TCPDump cross-compiling for Android:
<ul>
<li>http://www.androidtcpdump.com/android-tcpdump/compile</li>
</ul>
</li>
<li>ARM Cross Compiling with Mac OS X:
<ul>
<li>http://www.welzels.de/blog/en/arm-cross-compiling-with-mac-os-x</li>
</ul>
</li>
<li>Pre-built environment for Raspberry Pi cross-compiling and NFS booting:
<ul>
<li>https://forum.openframeworks.cc/t/pre-built-environment-for-raspberry-pi-cross-compiling-and-nfs-booting/16206/26</li>
<li>https://github.com/twobitcircus/rpi-build-and-boot</li>
</ul>
</li>
<li>How to Build a GCC Cross-Compiler:
<ul>
<li>http://preshing.com/20141119/how-to-build-a-gcc-cross-compiler</li>
</ul>
</li>
<li>A Vagrant plugin to keep your VirtualBox Guest Additions up to date:
<ul>
<li>https://github.com/dotless-de/vagrant-vbguest</li>
</ul>
</li>
<li>openFrameworks - an open source C++ toolkit:
<ul>
<li>http://openframeworks.cc/download</li>
</ul>
</li>
<li>Vboxvfs lacks support for symbolic / hard links
<ul>
<li>https://www.virtualbox.org/ticket/818</li>
</ul>
</li>
<li>Cross compiler for OF 0.9.0/Jessie/arm6/RPi1
<ul>
<li>https://forum.openframeworks.cc/t/cross-compiler-for-of-0-9-0-jessie-arm6-rpi1/21336</li>
</ul>
</li>
<li>How to cross compile an application for OpenWRT
<ul>
<li>https://blog.netbeast.co/app-openwrt</li>
</ul>
</li>
<li>Cross-Compiling or Building Android tcpdump?
<ul>
<li>http://www.androidtcpdump.com/android-tcpdump/compile</li>
</ul>
</li>
</ol>
